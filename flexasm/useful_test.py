import flexasm

s = flexasm.InstructionSet('camerondm9_useful')
s.instruction_format('dst-imm', ('opcode', 4), ('mode', 2), ('dst', 3), ('imm', 7))
s.instruction_format('dst-src-imm', ('opcode', 4), ('mode', 2), ('dst', 3), ('src', 3), ('imm', 4))
s.instruction_format('dst-src-follow', ('opcode', 4), ('mode', 2), ('dst', 3), ('src', 3), ('imm', 4), ('follow', 16))

for r in ['ax', 'bx', 'cx', 'dx', 'ex', 'fx', 'gx', 'sp']:
	s.register(r, width=16)

# m = s.address_space('unified', 32, 8)

# m = flexasm.AddressSpace(s)

s.instruction_element('reg', flexasm.options(lambda o: o
	('ax', dst=0)
	('bx', dst=1)
	('cx', dst=2)
	('dx', dst=3)
	('ex', dst=4)
	('fx', dst=5)
	('gx', dst=6)
	('sp', dst=7)
))
s.instruction_element('ri', flexasm.expression('src_imm'))
s.instruction_element('imm', flexasm.expression('imm'))
s.instruction_element('io', flexasm.expression('io'))
s.instruction_element('mem', flexasm.expression('mem'))
s.instruction_element('li', flexasm.expression('li'))

s.instruction('nop', opcode=0, mode=0, dst=0, imm=0)
s.instruction('jumpi {imm}', opcode=0, mode=1, dst=0, imm=0, follow='F')
s.instruction('return', opcode=0, mode=1, dst=0, imm=0x77)
s.instruction('enable', opcode=0, mode=2, dst=0, imm=0)
s.instruction('disable', opcode=0, mode=3, dst=0, imm=0)
s.instruction('in {reg}, {io}', opcode=1, mode=0, dst='reg', src=0, imm='io')
s.instruction('out {reg}, {io}', opcode=1, mode=1, dst='reg', src=0, imm='io')
s.instruction('neg {reg}', opcode=1, mode=2, dst=0, imm=0)
s.instruction('RESERVED {reg}', opcode=1, mode=3, dst=0, imm=0)
s.instruction('shl {reg}, {ri}', opcode=2)
s.instruction('shr {reg}, {ri}', opcode=3)
s.instruction('add {reg}, {ri}', opcode=4)
s.instruction('sub {reg}, {ri}', opcode=5)
s.instruction('load {reg}, {mem}', opcode=6)
s.instruction('pop {reg}', opcode=6)
s.instruction('store {reg}, {mem}', opcode=7)
s.instruction('push {reg}', opcode=7)
s.instruction('and {reg}, {ri}', opcode=8)
s.instruction('or {reg}, {ri}', opcode=9)
s.instruction('xor {reg}, {ri}', opcode=10)
s.instruction('move {reg}, {ri}', opcode=11)
s.instruction('jump {ri}', opcode=12)
s.instruction('call {ri}', opcode=12)
s.instruction('jg {reg}, {ri}, {li}', opcode=13)
s.instruction('jng {reg}, {ri}, {li}', opcode=13)
s.instruction('je {reg}, {ri}, {li}', opcode=14)
s.instruction('jne {reg}, {ri}, {li}', opcode=14)
s.instruction('jl {reg}, {ri}, {li}', opcode=15)
s.instruction('jnl {reg}, {ri}, {li}', opcode=15)

# s.directive('@add {imm}')
# s.directive('@align {imm}')

a = flexasm.Assembler(s)
print(a.process_file('flexasm/test.asm'))
